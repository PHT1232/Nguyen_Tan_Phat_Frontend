//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.1.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import {
  mergeMap as _observableMergeMap,
  catchError as _observableCatch,
} from "rxjs/operators";
import {
  Observable,
  throwError as _observableThrow,
  of as _observableOf,
  Subject,
} from "rxjs";
import { Injectable, Inject, Optional, InjectionToken } from "@angular/core";
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
} from "@angular/common/http";

import * as moment from "moment";

import { StorageProduct } from "./dtos/products/StorageProduct";
import {
  CategoryProduct,
  CategoryProductList,
} from "./dtos/products/CategoryProduct";
import { ProductOutputDto } from "./dtos/products/ProductOutputDto";
import {
  StorageProductDetail,
  StorageProductDetailList,
} from "./dtos/products/StorageProductDetail";
import { ProductInputDto } from "./dtos/products/ProductInputDto";
import { ListProductGetAll, ProductGetAllDto } from "./dtos/products/ProductGetAllDto";
import { ProductGetAllPagedResultDto } from "./dtos/products/ProductGetAllPagedResultDto";
import {
  SubcategoryProduct,
  SubcategoryProductList,
} from "./dtos/products/SubcategoryProduct";
import { LookUpTable, LookUpTableList } from "./dtos/LookUpTable";
import { AppConfig } from "./dtos/layout-service/AppConfig";
import { StructureInputDto } from "./dtos/Structure/StructureInputDto";
import { StructureGetallDto } from "./dtos/Structure/StructureGetallDto";
import { StructureOutputDto } from "./dtos/Structure/StructureOutputDto";
import { StructureSelectList } from "./dtos/Structure/StructureSelectDto";
import { StructureGetAllPagedResultDto } from "./dtos/Structure/StructureGetallPagedResultDto";
import { EmployeeGetAllPagedResultDto } from "./dtos/employee/EmployeeGetallPagedResultDto";
import { EmployeeInputDto } from "./dtos/employee/EmployeeInputDto";
import { CMNDDto } from "./dtos/employee/CMNDDto";
import { EmployeeOutputDto } from "./dtos/employee/EmployeeOutputDto";
import { EmployeeSelectForAccountList } from "./dtos/employee/EmployeeSelectForAccount";
import { CustomerInputDto } from "./dtos/customer/CustomerInputDto";
import { CustomerGetAllDtoPagedResultDto } from "./dtos/customer/CustomerGetAllPagedResultDto";
import { CustomerOutputDto } from "./dtos/customer/CustomerOutputDto";
import { ExpensesGetAllDto } from "./dtos/expenses/ExpensesGetAllDto";
import { ExpensesInputDto } from "./dtos/expenses/ExpensesInputDto";
import { ExpensesGetAllPagedResultDto } from "./dtos/expenses/ExpensesGetAllPagedResultDto";
import { ExpensesProductDto } from "./dtos/expenses/ExpensesProductDto";
import { ExpensesProductPagedResultDto } from "./dtos/expenses/ExpensesProductPagedResultDto";
import { RetailInputDto } from "./dtos/retail/RetailInputDto";
import { RetailCustomerDto } from "./dtos/retail/RetailCustomerDto";
import { RetailGetAllDto } from "./dtos/retail/RetailGetAllDto";
import { RetailGetAllPagedResultDto } from "./dtos/retail/RetailGetAllPagedResultDto";
import { RetailOutputDto } from "./dtos/retail/RetailOutputDto";
import { RetailProductDto } from "./dtos/retail/RetailProductDto";
import { BaoGiaObject } from "./dtos/BaoGiaObject";
import { DatasetDto, DatasetDtoList } from "./dtos/DatasetDto";
import { RetailPagedResult } from "./dtos/retail/RetailPagedResult";
import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http';

@Injectable()
export class AddCsrfHeaderInterceptorService implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
      const requestToken = this.getCookieValue('XSRF-TOKEN');
      return next.handle(req.clone({
          headers: req.headers.set('X-XSRF-TOKEN', requestToken)
      }));
  }

  private getCookieValue(cookieName: string) {
    const allCookies = decodeURIComponent(document.cookie).split('; ');
    for (let i = 0; i < allCookies.length; i++) {
        const cookie = allCookies[i];
        if (cookie.startsWith(cookieName + '=')){
            return cookie.substring(cookieName.length + 1);
        }
    }
    return '';
  }
} 

export const API_BASE_URL = new InjectionToken<string>("API_BASE_URL");

//#region Framework service
@Injectable()
export class AccountServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  isTenantAvailable(
    body: IsTenantAvailableInput | undefined
  ): Observable<IsTenantAvailableOutput> {
    let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIsTenantAvailable(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIsTenantAvailable(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<IsTenantAvailableOutput>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<IsTenantAvailableOutput>;
        })
      );
  }

  protected processIsTenantAvailable(
    response: HttpResponseBase
  ): Observable<IsTenantAvailableOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = IsTenantAvailableOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  register(body: RegisterInput | undefined): Observable<RegisterOutput> {
    let url_ = this.baseUrl + "/api/services/app/Account/Register";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegister(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegister(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RegisterOutput>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<RegisterOutput>;
        })
      );
  }

  protected processRegister(
    response: HttpResponseBase
  ): Observable<RegisterOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RegisterOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class ConfigurationServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changeUiTheme(body: ChangeUiThemeInput | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeUiTheme(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeUiTheme(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class RoleServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateRoleDto | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RoleDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RoleDto>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param permission (optional)
   * @return Success
   */
  getRoles(
    permission: string | undefined
  ): Observable<RoleListDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
    if (permission === null)
      throw new Error("The parameter 'permission' cannot be null.");
    else if (permission !== undefined)
      url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoles(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<RoleListDtoListResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<RoleListDtoListResultDto>;
        })
      );
  }

  protected processGetRoles(
    response: HttpResponseBase
  ): Observable<RoleListDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleListDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: RoleDto | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RoleDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RoleDto>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getAllPermissions(): Observable<PermissionDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllPermissions(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllPermissions(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PermissionDtoListResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PermissionDtoListResultDto>;
        })
      );
  }

  protected processGetAllPermissions(
    response: HttpResponseBase
  ): Observable<PermissionDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PermissionDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoleForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoleForEdit(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<GetRoleForEditOutput>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<GetRoleForEditOutput>;
        })
      );
  }

  protected processGetRoleForEdit(
    response: HttpResponseBase
  ): Observable<GetRoleForEditOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetRoleForEditOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<RoleDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RoleDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RoleDto>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<RoleDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param keyword (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<RoleDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<RoleDtoPagedResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<RoleDtoPagedResultDto>;
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<RoleDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class SessionServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @return Success
   */
  getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
    let url_ =
      this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCurrentLoginInformations(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCurrentLoginInformations(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<GetCurrentLoginInformationsOutput>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<GetCurrentLoginInformationsOutput>;
        })
      );
  }

  protected processGetCurrentLoginInformations(
    response: HttpResponseBase
  ): Observable<GetCurrentLoginInformationsOutput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class TenantServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateTenantDto | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TenantDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<TenantDto>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TenantDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<TenantDto>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param keyword (optional)
   * @param isActive (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    isActive: boolean | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<TenantDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (isActive === null)
      throw new Error("The parameter 'isActive' cannot be null.");
    else if (isActive !== undefined)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<TenantDtoPagedResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<TenantDtoPagedResultDto>;
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<TenantDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: TenantDto | undefined): Observable<TenantDto> {
    let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TenantDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<TenantDto>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class TokenAuthServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  authenticate(
    body: AuthenticateModel | undefined
  ): Observable<AuthenticateResultModel> {
    let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        headerName: "X-XSRF-TOKEN",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAuthenticate(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<AuthenticateResultModel>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<AuthenticateResultModel>;
        })
      );
  }

  protected processAuthenticate(
    response: HttpResponseBase
  ): Observable<AuthenticateResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getExternalAuthenticationProviders(): Observable<
    ExternalLoginProviderInfoModel[]
  > {
    let url_ =
      this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetExternalAuthenticationProviders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetExternalAuthenticationProviders(
                response_ as any
              );
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                ExternalLoginProviderInfoModel[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ExternalLoginProviderInfoModel[]
            >;
        })
      );
  }

  protected processGetExternalAuthenticationProviders(
    response: HttpResponseBase
  ): Observable<ExternalLoginProviderInfoModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200.push(ExternalLoginProviderInfoModel.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  externalAuthenticate(
    body: ExternalAuthenticateModel | undefined
  ): Observable<ExternalAuthenticateResultModel> {
    let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExternalAuthenticate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExternalAuthenticate(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ExternalAuthenticateResultModel>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ExternalAuthenticateResultModel>;
        })
      );
  }

  protected processExternalAuthenticate(
    response: HttpResponseBase
  ): Observable<ExternalAuthenticateResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable()
export class UserServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  create(body: CreateUserDto | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/Create";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserDto>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  update(body: UserDto | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserDto>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  delete(id: number | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/User/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  activate(body: Int64EntityDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/User/Activate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processActivate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processActivate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processActivate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  deActivate(body: Int64EntityDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/User/DeActivate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeActivate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeActivate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDeActivate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @return Success
   */
  getRoles(): Observable<RoleDtoListResultDto> {
    let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRoles(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRoles(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<RoleDtoListResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<RoleDtoListResultDto>;
        })
      );
  }

  protected processGetRoles(
    response: HttpResponseBase
  ): Observable<RoleDtoListResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RoleDtoListResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeLanguage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeLanguage(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processChangeLanguage(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  changePassword(body: ChangePasswordDto | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangePassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangePassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processChangePassword(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  resetPassword(body: ResetPasswordDto | undefined): Observable<boolean> {
    let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("post", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetPassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<boolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<boolean>;
        })
      );
  }

  protected processResetPassword(
    response: HttpResponseBase
  ): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: number | undefined): Observable<UserDto> {
    let url_ = this.baseUrl + "/api/services/app/User/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<UserDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<UserDto>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<UserDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  /**
   * @param keyword (optional)
   * @param isActive (optional)
   * @param skipCount (optional)
   * @param maxResultCount (optional)
   * @return Success
   */
  getAll(
    keyword: string | undefined,
    isActive: boolean | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<UserDtoPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (isActive === null)
      throw new Error("The parameter 'isActive' cannot be null.");
    else if (isActive !== undefined)
      url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<UserDtoPagedResultDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<UserDtoPagedResultDto>;
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<UserDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = UserDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}
//#endregion

//#region my service
//#region LayoutService
interface LayoutState {
  staticMenuDesktopInactive: boolean;
  overlayMenuActive: boolean;
  profileSidebarVisible: boolean;
  configSidebarVisible: boolean;
  staticMenuMobileActive: boolean;
  menuHoverActive: boolean;
}
@Injectable({
  providedIn: "root",
})
export class LayoutService {
  config: AppConfig = {
    ripple: false,
    inputStyle: "outlined",
    menuMode: "static",
    colorScheme: "light",
    theme: "lara-light-indigo",
    scale: 14,
  };

  state: LayoutState = {
    staticMenuDesktopInactive: false,
    overlayMenuActive: false,
    profileSidebarVisible: false,
    configSidebarVisible: false,
    staticMenuMobileActive: false,
    menuHoverActive: false,
  };

  private configUpdate = new Subject<AppConfig>();

  private overlayOpen = new Subject<any>();

  configUpdate$ = this.configUpdate.asObservable();

  overlayOpen$ = this.overlayOpen.asObservable();

  onMenuToggle() {
    if (this.isOverlay()) {
      this.state.overlayMenuActive = !this.state.overlayMenuActive;
      if (this.state.overlayMenuActive) {
        this.overlayOpen.next(null);
      }
    }

    if (this.isDesktop()) {
      this.state.staticMenuDesktopInactive =
        !this.state.staticMenuDesktopInactive;
    } else {
      this.state.staticMenuMobileActive = !this.state.staticMenuMobileActive;

      if (this.state.staticMenuMobileActive) {
        this.overlayOpen.next(null);
      }
    }
  }

  showProfileSidebar() {
    this.state.profileSidebarVisible = !this.state.profileSidebarVisible;
    if (this.state.profileSidebarVisible) {
      this.overlayOpen.next(null);
    }
  }

  showConfigSidebar() {
    this.state.configSidebarVisible = true;
  }

  isOverlay() {
    return this.config.menuMode === "overlay";
  }

  isDesktop() {
    return window.innerWidth > 991;
  }

  isMobile() {
    return !this.isDesktop();
  }

  onConfigUpdate() {
    this.configUpdate.next(this.config);
  }
}
//#endregion
//#region Storage service
@Injectable()
export class StorageServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  createStorage(body: StorageInput | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/Storage/AddNew";
    _url = _url.replace(/[?&]$/, "");

    const _content = JSON.stringify(body);

    let _options: any = {
      body: _content,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processAdd(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(_response));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }

    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            Headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  update(body: StorageInput | undefined): Observable<StorageInput> {
    let url_ = this.baseUrl + "/api/services/app/Storage/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<StorageInput>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<StorageInput>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<StorageInput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StorageInput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StorageInput>(<any>null);
  }

  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<GetAllStoragePagedResultDto> {
    let _url = this.baseUrl + "/api/services/app/Storage/GetAll";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      _url += "?Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      _url += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      _url += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";

    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", _url, _options)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<GetAllStoragePagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<GetAllStoragePagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<GetAllStoragePagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetAllStoragePagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GetAllStoragePagedResultDto>(<any>null);
  }

  getStorageForEdit(id: string | undefined): Observable<StorageForUpdate> {
    let url_ = this.baseUrl + "/api/services/app/Storage/GetUpdate?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetStorageForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetStorageForEdit(<any>response_);
            } catch (e) {
              return <Observable<StorageForUpdate>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<StorageForUpdate>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetStorageForEdit(
    response: HttpResponseBase
  ): Observable<StorageForUpdate> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StorageForUpdate.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StorageForUpdate>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: string | undefined): Observable<StorageOutPutDto> {
    let url_ = this.baseUrl + "/api/services/app/Storage/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<StorageOutPutDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<StorageOutPutDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<StorageOutPutDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StorageOutPutDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StorageOutPutDto>(<any>null);
  }

  getProduct(id: string | undefined): Observable<StorageOutPutDto> {
    let url_ = this.baseUrl + "/api/services/app/Storage/GetProduct?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProduct(<any>response_);
            } catch (e) {
              return <Observable<StorageOutPutDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<StorageOutPutDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetProduct(
    response: HttpResponseBase
  ): Observable<StorageOutPutDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StorageOutPutDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StorageOutPutDto>(<any>null);
  }

  deleteMutiple(ids: string[] | undefined): Observable<string> {
    let _url = this.baseUrl + "/api/services/app/Storage/DeleteMultiple?";
    if (ids === null) throw new Error("The parameter 'id' cannot be null");
    else if (ids !== undefined) {
      ids.forEach((element) => {
        _url += "ids=" + encodeURIComponent("" + element) + "&";
      });
    }
    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processDeleteMutiple(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processDeleteMutiple(<any>_response);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processDeleteMutiple(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<string>(<any>_responseText);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  delete(id: string | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/Storage/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null");
    else if (id !== undefined)
      _url += "Id=" + encodeURIComponent("" + id) + "&";
    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processDelete(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}
//#endregion
//#region Category service
@Injectable()
export class CategoryServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  create(body: CategoryInput | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/Category/AddNew";
    _url = _url.replace(/[?&]$/, "");

    const _content = JSON.stringify(body);

    let _options: any = {
      body: _content,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processAdd(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(_response));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }

    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            Headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  update(body: CategoryInput | undefined): Observable<CategoryInput> {
    let url_ = this.baseUrl + "/api/services/app/Category/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<CategoryInput>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<CategoryInput>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<CategoryInput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CategoryInput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CategoryInput>(<any>null);
  }

  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<GetAllCategoryPagedResultDto> {
    let _url = this.baseUrl + "/api/services/app/Category/GetAll";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      _url += "?Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      _url += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      _url += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";

    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", _url, _options)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<GetAllCategoryPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<GetAllCategoryPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<GetAllCategoryPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetAllCategoryPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GetAllCategoryPagedResultDto>(<any>null);
  }

  getCategoryForEdit(id: string | undefined): Observable<CategoryOutputDto> {
    let url_ = this.baseUrl + "/api/services/app/Category/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetStorageForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetStorageForEdit(<any>response_);
            } catch (e) {
              return <Observable<CategoryOutputDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<CategoryOutputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetStorageForEdit(
    response: HttpResponseBase
  ): Observable<CategoryOutputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CategoryOutputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CategoryOutputDto>(<any>null);
  }

  delete(id: string | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/Category/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null");
    else if (id !== undefined)
      _url += "Id=" + encodeURIComponent("" + id) + "&";
    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processDelete(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}
//#endregion
//#region Structure service
@Injectable()
export class StructureServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  createStructure(body: StructureInputDto | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/Structure/AddNew";
    _url = _url.replace(/[?&]$/, "");

    const _content = JSON.stringify(body);

    let _options: any = {
      body: _content,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processAdd(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(_response));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }

    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            Headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  update(body: StructureInputDto | undefined): Observable<StructureInputDto> {
    let url_ = this.baseUrl + "/api/services/app/Structure/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<StructureInputDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<StructureInputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<StructureInputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StructureInputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StructureInputDto>(<any>null);
  }

  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<StructureGetAllPagedResultDto> {
    let _url = this.baseUrl + "/api/services/app/Structure/GetAll";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      _url += "?Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      _url += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      _url += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";

    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", _url, _options)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<StructureGetAllPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<StructureGetAllPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<StructureGetAllPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StructureGetAllPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StructureGetAllPagedResultDto>(<any>null);
  }

  getStructureForEdit(id: string | undefined): Observable<StructureOutputDto> {
    let url_ = this.baseUrl + "/api/services/app/Structure/GetUpdate?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetStorageForEdit(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetStorageForEdit(<any>response_);
            } catch (e) {
              return <Observable<StructureOutputDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<StructureOutputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetStorageForEdit(
    response: HttpResponseBase
  ): Observable<StructureOutputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StructureOutputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StructureOutputDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: string | undefined): Observable<StructureOutputDto> {
    let url_ = this.baseUrl + "/api/services/app/Structure/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<StructureOutputDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<StructureOutputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<StructureOutputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StructureOutputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StructureOutputDto>(<any>null);
  }

  delete(id: string | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/Structure/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null");
    else if (id !== undefined)
      _url += "Id=" + encodeURIComponent("" + id) + "&";
    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processDelete(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  getStructureSelect(): Observable<StructureSelectList> {
    let url_ = this.baseUrl + "/api/services/app/Structure/GetStructureSelect";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSelect(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSelect(<any>response_);
            } catch (e) {
              return <Observable<StructureSelectList>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<StructureSelectList>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetSelect(
    response: HttpResponseBase
  ): Observable<StructureSelectList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StructureSelectList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StructureSelectList>(<any>null);
  }
}
//#endregion
//#region Customer service
@Injectable()
export class CustomerServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  create(body: CustomerInputDto | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/Customer/AddNew";
    _url = _url.replace(/[?&]$/, "");

    const _content = JSON.stringify(body);

    let _options: any = {
      body: _content,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processAdd(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(_response));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }

    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            Headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  update(body: CustomerInputDto | undefined): Observable<CustomerInputDto> {
    let url_ = this.baseUrl + "/api/services/app/Customer/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<CustomerInputDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<CustomerInputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<CustomerInputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CustomerInputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CustomerInputDto>(<any>null);
  }

  getAll(
    keyword: string | undefined,
    skipCount: number | undefined,
    isRetail: boolean | undefined,
    maxResultCount: number | undefined
  ): Observable<CustomerGetAllDtoPagedResultDto> {
    let _url = this.baseUrl + "/api/services/app/Customer/GetAll";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      _url += "?Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (isRetail === null)
      throw new Error("The parameter 'isRetail' cannot be null.");
    else if (isRetail !== undefined)
      _url += "isRetail=" + encodeURIComponent("" + isRetail) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      _url += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      _url += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";

    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", _url, _options)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<CustomerGetAllDtoPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<CustomerGetAllDtoPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<CustomerGetAllDtoPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CustomerGetAllDtoPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CustomerGetAllDtoPagedResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: string | undefined): Observable<CustomerOutputDto> {
    let url_ = this.baseUrl + "/api/services/app/Customer/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<CustomerOutputDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<CustomerOutputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<CustomerOutputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CustomerOutputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CustomerOutputDto>(<any>null);
  }

  delete(id: string | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/Customer/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null");
    else if (id !== undefined)
      _url += "Id=" + encodeURIComponent("" + id) + "&";
    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processDelete(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  deleteMutiple(ids: string[] | undefined): Observable<string> {
    let _url = this.baseUrl + "/api/services/app/Employee/DeleteMultiple?";
    if (ids === null) {
      throw new Error("The parameter 'id' cannot be null");
    } else if (ids !== undefined) {
      ids.forEach((element) => {
        _url += "ids=" + encodeURIComponent("" + element) + "&";
      });
    }
    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processDeleteMutiple(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processDeleteMutiple(<any>_response);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processDeleteMutiple(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<string>(<any>_responseText);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }
}
//#endregion
//#region Employee service
@Injectable()
export class EmployeeServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  create(body: EmployeeInputDto | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/Employee/AddNew";
    _url = _url.replace(/[?&]$/, "");

    const _content = JSON.stringify(body);

    let _options: any = {
      body: _content,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processAdd(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(_response));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }

    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            Headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  update(body: EmployeeInputDto | undefined): Observable<EmployeeInputDto> {
    let url_ = this.baseUrl + "/api/services/app/Employee/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<EmployeeInputDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<EmployeeInputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<EmployeeInputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EmployeeInputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EmployeeInputDto>(<any>null);
  }

  getAll(
    keyword: string | undefined,
    unitCode: string | undefined,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<EmployeeGetAllPagedResultDto> {
    let _url = this.baseUrl + "/api/services/app/Employee/GetAll";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      _url += "?Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (unitCode === null)
      throw new Error("The parameter 'unitCode' cannot be null.");
    else if (unitCode !== undefined)
      _url += "UnitCode=" + encodeURIComponent("" + unitCode) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      _url += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      _url += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";

    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", _url, _options)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<EmployeeGetAllPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<EmployeeGetAllPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<EmployeeGetAllPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EmployeeGetAllPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EmployeeGetAllPagedResultDto>(<any>null);
  }

  /**
   * @param id (optional)
   * @return Success
   */
  get(id: string | undefined): Observable<EmployeeOutputDto> {
    let url_ = this.baseUrl + "/api/services/app/Employee/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "Id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<EmployeeOutputDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<EmployeeOutputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<EmployeeOutputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EmployeeOutputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EmployeeOutputDto>(<any>null);
  }

  getEmployeeForSelect(): Observable<EmployeeSelectForAccountList> {
    let _url = this.baseUrl + "/api/services/app/Employee/GetEmployeeSelect";
    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processGetEmployeeSelect(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processGetEmployeeSelect(<any>_response);
            } catch (e) {
              return <Observable<EmployeeSelectForAccountList>>(
                (<any>_observableThrow(e))
              );
            }
          } else {
            return <Observable<EmployeeSelectForAccountList>>(
              (<any>_observableThrow(_response))
            );
          }
        })
      );
  }

  protected processGetEmployeeSelect(
    response: HttpResponseBase
  ): Observable<EmployeeSelectForAccountList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = EmployeeSelectForAccountList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<EmployeeSelectForAccountList>(<any>null);
  }

  getEmployeeForSelectWithStructureId(id: string): Observable<EmployeeSelectForAccountList> {
    let _url = this.baseUrl + "/api/services/app/Employee/GetEmployeeSelectWithStructureId?";
    if (id !== undefined)
      _url += "StructureId=" + encodeURIComponent("" + id) + "&"; 
    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processGetEmployeeSelect(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processGetEmployeeSelect(<any>_response);
            } catch (e) {
              return <Observable<EmployeeSelectForAccountList>>(
                (<any>_observableThrow(e))
              );
            }
          } else {
            return <Observable<EmployeeSelectForAccountList>>(
              (<any>_observableThrow(_response))
            );
          }
        })
      );
  }

  delete(id: string | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/Employee/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null");
    else if (id !== undefined)
      _url += "Id=" + encodeURIComponent("" + id) + "&";
    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processDelete(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  deleteMutiple(ids: string[] | undefined): Observable<string> {
    let _url = this.baseUrl + "/api/services/app/Employee/DeleteMultiple?";
    if (ids === null) {
      throw new Error("The parameter 'id' cannot be null");
    } else if (ids !== undefined) {
      ids.forEach((element) => {
        _url += "ids=" + encodeURIComponent("" + element) + "&";
      });
    }
    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processDeleteMutiple(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processDeleteMutiple(<any>_response);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processDeleteMutiple(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<string>(<any>_responseText);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  getStructureSelect(): Observable<StructureSelectList> {
    let url_ = this.baseUrl + "/api/services/app/Structure/GetStructureSelect";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSelect(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSelect(<any>response_);
            } catch (e) {
              return <Observable<StructureSelectList>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<StructureSelectList>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetSelect(
    response: HttpResponseBase
  ): Observable<StructureSelectList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StructureSelectList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StructureSelectList>(<any>null);
  }
}
//#endregion

@Injectable()
export class ProductServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  create(body: ProductInputDto | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/Product/AddNew";
    _url = _url.replace(/[?&]$/, "");

    const _content = JSON.stringify(body);

    let _options: any = {
      body: _content,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processAdd(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(_response));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }

    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            Headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  update(body: ProductInputDto | undefined): Observable<ProductInputDto> {
    let url_ = this.baseUrl + "/api/services/app/Product/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<ProductInputDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ProductInputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<ProductInputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProductInputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ProductInputDto>(<any>null);
  }

  getAll(
    keyword: string | undefined,
    storageCode: string,
    categoryCode: string,
    subcategoryCode: number,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<ProductGetAllPagedResultDto> {
    let _url = this.baseUrl + "/api/services/app/Product/GetAll";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      _url += "?Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (storageCode !== undefined)
      _url += "StorageCode=" + encodeURIComponent("" + storageCode) + "&";
    if (categoryCode !== undefined)
      _url += "CategoryCode=" + encodeURIComponent("" + categoryCode) + "&";
    if (subcategoryCode !== undefined)
      _url +=
        "SubCategoryCode=" + encodeURIComponent("" + subcategoryCode) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      _url += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      _url += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";

    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", _url, _options)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<ProductGetAllPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ProductGetAllPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<ProductGetAllPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProductGetAllPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ProductGetAllPagedResultDto>(<any>null);
  }  
  

  getCategoryProduct(): Observable<CategoryProductList> {
    let url_ = this.baseUrl + "/api/services/app/Product/GetCategoryProduct";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCategoryProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCategoryProduct(<any>response_);
            } catch (e) {
              return <Observable<CategoryProductList>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<CategoryProductList>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetCategoryProduct(
    response: HttpResponseBase
  ): Observable<CategoryProductList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CategoryProductList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CategoryProductList>(<any>null);
  }

  getSubcategoryProduct(id: string): Observable<SubcategoryProductList> {
    let url_ =
      this.baseUrl + "/api/services/app/Product/GetSubcategoryProduct?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "categoryId=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSubcategoryProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSubcategoryProduct(<any>response_);
            } catch (e) {
              return <Observable<SubcategoryProductList>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<SubcategoryProductList>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetSubcategoryProduct(
    response: HttpResponseBase
  ): Observable<SubcategoryProductList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SubcategoryProductList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<SubcategoryProductList>(<any>null);
  }

  getStorageProduct(): Observable<StorageProductDetailList> {
    let url_ = this.baseUrl + "/api/services/app/Product/GetStorageProduct";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processStorageProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processStorageProduct(<any>response_);
            } catch (e) {
              return <Observable<StorageProductDetailList>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<StorageProductDetailList>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processStorageProduct(
    response: HttpResponseBase
  ): Observable<StorageProductDetailList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = StorageProductDetailList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<StorageProductDetailList>(<any>null);
  }  
  
  getStorageExpense(): Observable<LookUpTableList> {
    let url_ = this.baseUrl + "/api/services/app/Product/GetStorageExpense";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetStorageExpenses(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetStorageExpenses(<any>response_);
            } catch (e) {
              return <Observable<LookUpTableList>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<LookUpTableList>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetStorageExpenses(
    response: HttpResponseBase
  ): Observable<LookUpTableList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LookUpTableList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LookUpTableList>(<any>null);
  }

  getProduct(id: string | undefined): Observable<ProductOutputDto> {
    let url_ = this.baseUrl + "/api/services/app/Product/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProduct(<any>response_);
            } catch (e) {
              return <Observable<ProductOutputDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ProductOutputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetProduct(
    response: HttpResponseBase
  ): Observable<ProductOutputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProductOutputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ProductOutputDto>(<any>null);
  }

  delete(id: string | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/Product/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null");
    else if (id !== undefined)
      _url += "Id=" + encodeURIComponent("" + id) + "&";
    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processDelete(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

//#region File Service
@Injectable()
export class FileDownloadService {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  downloadTempFile(file: string) {
    const url = this.baseUrl + '/File/DownloadTempFile?file=' + file;
    // TODO: This causes reloading of same page in Firefox
    location.href = url;
  }

  exportToExcel(id: string, isRetail: boolean): Observable<boolean> {
    const url = this.baseUrl + '/File/ExcelExport?id=' + id + '&isRetail=' + isRetail;
    // TODO: This causes reloading of same page in Firefox
    location.href = url;
    return _observableOf(true);
  }  
  
  exportToExcelDelivery(id: string, isRetail: boolean): Observable<boolean> {
    const url = this.baseUrl + '/File/ExcelExportForXuatHang?id=' + id + '&isRetail=' + isRetail;
    // TODO: This causes reloading of same page in Firefox
    location.href = url;
    return _observableOf(true);
  }  
  
  exportToExcelSalary(id: string, date: string): Observable<boolean> {
    const url = this.baseUrl + '/File/ExcelExportForSalary?structureId=' + id + "&date=" + date;
    // TODO: This causes reloading of same page in Firefox
    location.href = url;
    return _observableOf(true);
  }

  exportToExcelBaoGia(body: any | undefined): Observable<boolean> {
    var url = this.baseUrl + '/File/ExcelExportForBaoGia?fileBytes=' + body;
    // TODO: This causes reloading of same page in Firefox
    location.href = url;
    return _observableOf(true);
  }

  getByte(body: BaoGiaObject | undefined): Observable<any> {
    let _url = this.baseUrl + "/api/services/app/ExportImport/GetByteForExcelExport?";
    body.products.forEach(element => {
      _url += "products=" + encodeURIComponent("" + element) + "&";
    });
    _url = _url.replace(/[?&]$/, "");

    const _content = JSON.stringify(body);

    let _options: any = {
      body: _content,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("get", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processAdd(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>_response);
            } catch (e) {
              return <Observable<any>>(<any>_observableThrow(_response));
            }
          } else return <Observable<any>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<any> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }

    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<any>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            Headers
          );
        })
      );
    }
    return _observableOf<any>(<any>null);
  }

}
//#endregion

//#region VnPayService
@Injectable()
export class VnPayService {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  createPaymentUrl(id: string) {
    const url = this.baseUrl + '/api/Upload/CreatePaymentUrl?id=' + id;
    this.http.get<string>(url).subscribe(res => {
      location.href = res['result'].toString();
    });
  }
}

//#region Upload Service 
@Injectable()
export class UploadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    downloadTempFile(file: string) {
      const url = this.baseUrl + '/File/DownloadTempFile?file=' + file;
      // TODO: This causes reloading of same page in Firefox
      location.href = url;
    }

    testUpload(): Observable<string[]> {
        let _url = this.baseUrl + "/api/Upload/DemoUpload";
        _url = _url.replace(/[?&]$/, "");

        let _options: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", _url, _options).pipe(_observableMergeMap((_response: any) => {
            return this.processDemoUpload(_response);
        })).pipe(_observableCatch((_response: any) => {
            if (_response instanceof HttpResponseBase) {
                try {
                    return this.processDemoUpload(<any>_response);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(_response);
        }));
    }

    protected processDemoUpload(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200.push(item);
                }
                else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getFileUpload(linkFile: string): Observable<string> {
      let url_ = this.baseUrl + "/api/Upload/DownloadFileUpdload?";
      if (linkFile === null)
          throw new Error("The parameter 'linkFile' cannot be null.");
      else if (linkFile !== undefined)
          url_ += "linkFile=" + encodeURIComponent("" + linkFile) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "text/plain"
          })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processDownloadFileUpdload(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processDownloadFileUpdload(<any>response_);
              } catch (e) {
                  return <Observable<string>><any>_observableThrow(e);
              }
          } else
              return <Observable<string>><any>_observableThrow(response_);
      }));
    }

    protected processDownloadFileUpdload(response: HttpResponseBase): Observable<string> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200;
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<string>(<any>null);
  }    
  
  getDownloadExcel(linkFile: string): Observable<string> {
      let url_ = this.baseUrl + "/api/Upload/DownloadExcel?";
      if (linkFile === null)
          throw new Error("The parameter 'linkFile' cannot be null.");
      else if (linkFile !== undefined)
          url_ += "linkFile=" + encodeURIComponent("" + linkFile) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_ : any = {
          observe: "response",
          responseType: "blob",
          headers: new HttpHeaders({
              "Accept": "text/plain"
          })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
          return this.processDownloadExcel(response_);
      })).pipe(_observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
              try {
                  return this.processDownloadExcel(<any>response_);
              } catch (e) {
                  return <Observable<string>><any>_observableThrow(e);
              }
          } else
              return <Observable<string>><any>_observableThrow(response_);
      }));
    }

    protected processDownloadExcel(response: HttpResponseBase): Observable<string> {
      const status = response.status;
      const responseBlob =
          response instanceof HttpResponse ? response.body :
          (<any>response).error instanceof Blob ? (<any>response).error : undefined;

      let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
      if (status === 200) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200;
          return _observableOf(result200);
          }));
      } else if (status !== 200 && status !== 204) {
          return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
          }));
      }
      return _observableOf<string>(<any>null);
  }
}
//#endregion
//#endregion
//#region Export import service
@Injectable()
export class ExportImportService {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  create(body: ExportImportInput | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/ExportImport/AddNew";
    _url = _url.replace(/[?&]$/, "");

    const _content = JSON.stringify(body);

    let _options: any = {
      body: _content,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processAdd(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(_response));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }

    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            Headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  update(body: ExportImportInput | undefined): Observable<ExportImportInput> {
    let url_ = this.baseUrl + "/api/services/app/ExportImport/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<ExportImportInput>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ExportImportInput>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<ExportImportInput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExportImportInput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExportImportInput>(<any>null);
  }

  updateOrder(
    body: ExportImportInput | undefined
  ): Observable<ExportImportInput> {
    let url_ = this.baseUrl + "/api/services/app/ExportImport/UpdateOrder";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateOrder(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateOrder(<any>response_);
            } catch (e) {
              return <Observable<ExportImportInput>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ExportImportInput>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdateOrder(
    response: HttpResponseBase
  ): Observable<ExportImportInput> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExportImportInput.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExportImportInput>(<any>null);
  }

  getStorage(id: string): Observable<LookUpTableList> {
    let url_ = this.baseUrl + "/api/services/app/ExportImport/GetStorage?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetStorageExpenses(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetStorageExpenses(<any>response_);
            } catch (e) {
              return <Observable<LookUpTableList>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<LookUpTableList>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetStorageExpenses(
    response: HttpResponseBase
  ): Observable<LookUpTableList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LookUpTableList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LookUpTableList>(<any>null);
  }

  get(id: string | undefined): Observable<ExportImportOutputDto> {
    let url_ = this.baseUrl + "/api/services/app/ExportImport/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<ExportImportOutputDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ExportImportOutputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<ExportImportOutputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExportImportOutputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExportImportOutputDto>(<any>null);
  }

  getCustomerSelect(structureId: string): Observable<ListOfCustomer> {
    let url_ = this.baseUrl + "/api/services/app/ExportImport/GetCustomerList?";
    if (structureId === null) 
      throw new Error("The parameter 'structureId' cannot be null");
    else if (structureId !== undefined)
      url_ += "structureId=" + encodeURIComponent("" + structureId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCustomerSelect(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCustomerSelect(<any>response_);
            } catch (e) {
              return <Observable<ListOfCustomer>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ListOfCustomer>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetCustomerSelect(
    response: HttpResponseBase
  ): Observable<ListOfCustomer> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListOfCustomer.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ListOfCustomer>(<any>null);
  }

  getRandomCode(): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/ExportImport/GetRandomCode";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRandomCode(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRandomCode(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRandomCode(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  delete(id: string | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/ExportImport/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null");
    else if (id !== undefined)
      _url += "Id=" + encodeURIComponent("" + id) + "&";
    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processDelete(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  getCustomer(id: string): Observable<CustomerDto> {
    let url_ = this.baseUrl + "/api/services/app/ExportImport/GetCustomer?";
    if (id === null) throw new Error("The parameter 'id' cannot be null");
    else if (id !== undefined)
      url_ += "PhoneNumber=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCustomer(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCustomer(<any>response_);
            } catch (e) {
              return <Observable<CustomerDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<CustomerDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCustomer(
    response: HttpResponseBase
  ): Observable<CustomerDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CustomerDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<CustomerDto>(<any>null);
  }

  getProduct(
    keyword: string,
    storageId: string,
    isInsert: boolean,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<ExportImportPagedResult> {
    let url_ = this.baseUrl + "/api/services/app/ExportImport/GetProduct?";
    if (storageId !== undefined)
      url_ += "StorageId=" + encodeURIComponent("" + storageId) + "&";
    if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (isInsert !== undefined)
      url_ += "isInsert=" + encodeURIComponent("" + isInsert) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";

    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProduct(<any>response_);
            } catch (e) {
              return <Observable<ExportImportPagedResult>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ExportImportPagedResult>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetProduct(
    response: HttpResponseBase
  ): Observable<ExportImportPagedResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExportImportPagedResult.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExportImportPagedResult>(<any>null);
  }

  getUser(): Observable<LookUpTableList> {
    let url_ = this.baseUrl + "/api/services/app/ExportImport/GetCreator";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUser(<any>response_);
            } catch (e) {
              return <Observable<LookUpTableList>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LookUpTableList>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetUser(
    response: HttpResponseBase
  ): Observable<LookUpTableList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LookUpTableList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LookUpTableList>(<any>null);
  }

  getAll(
    keyword: string | undefined,
    storageCode: string,
    DateTime: string[],
    orderType: number,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<GetAllExportImportPagedResult> {
    let _url = this.baseUrl + "/api/services/app/ExportImport/GetAll";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      _url += "?Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (storageCode !== undefined)
      _url += "Storage=" + encodeURIComponent("" + storageCode) + "&";
    if (DateTime !== undefined) {
      DateTime.forEach((element) => {
        _url += "DateTime=" + encodeURIComponent("" + element) + "&";
      });
    }
    if (orderType !== 0)
      _url += "OrderStatus=" + encodeURIComponent("" + orderType) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      _url += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      _url += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";

    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", _url, _options)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<GetAllExportImportPagedResult>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<GetAllExportImportPagedResult>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<GetAllExportImportPagedResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = GetAllExportImportPagedResult.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<GetAllExportImportPagedResult>(<any>null);
  }
}
//#endregion
//#endregion
//#region Expense service
@Injectable()
export class ExpensesService {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  create(body: ExpensesInputDto | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/Expenses/AddNew";
    _url = _url.replace(/[?&]$/, "");

    const _content = JSON.stringify(body);

    let _options: any = {
      body: _content,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processAdd(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(_response));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }

    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            Headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  updateOrder(
    body: ExpensesInputDto | undefined
  ): Observable<ExpensesInputDto> {
    let url_ = this.baseUrl + "/api/services/app/Expenses/UpdateOrder";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateOrder(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateOrder(<any>response_);
            } catch (e) {
              return <Observable<ExpensesInputDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ExpensesInputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdateOrder(
    response: HttpResponseBase
  ): Observable<ExpensesInputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExpensesInputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExpensesInputDto>(<any>null);
  }

  get(id: string | undefined): Observable<ExpensesInputDto> {
    let url_ = this.baseUrl + "/api/services/app/Expenses/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<ExpensesInputDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<ExpensesInputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<ExpensesInputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExpensesInputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExpensesInputDto>(<any>null);
  }

  getRandomCode(): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/ExportImport/GetRandomCode";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRandomCode(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRandomCode(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRandomCode(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  delete(id: string | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/Expenses/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null");
    else if (id !== undefined)
      _url += "Id=" + encodeURIComponent("" + id) + "&";
    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processDelete(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  getProduct(
    storageId: string,
    isInsert: boolean,
    keyword: string,    
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<ExpensesProductPagedResultDto> {
    let url_ = this.baseUrl + "/api/services/app/Expenses/GetProduct?";
    if (storageId !== undefined)
      url_ += "StorageId=" + encodeURIComponent("" + storageId) + "&";    
    if (keyword !== undefined)
      url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
    if (isInsert !== undefined)
      url_ += "isInsert=" + encodeURIComponent("" + isInsert) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";

    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProduct(<any>response_);
            } catch (e) {
              return <Observable<ExpensesProductPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ExpensesProductPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetProduct(
    response: HttpResponseBase
  ): Observable<ExpensesProductPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExpensesProductPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExpensesProductPagedResultDto>(<any>null);
  }

  getUser(): Observable<LookUpTableList> {
    let url_ = this.baseUrl + "/api/services/app/Expenses/GetCreator";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUser(<any>response_);
            } catch (e) {
              return <Observable<LookUpTableList>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LookUpTableList>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetUser(
    response: HttpResponseBase
  ): Observable<LookUpTableList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LookUpTableList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LookUpTableList>(<any>null);
  }

  getAll(
    keyword: string | undefined,
    storageCode: string,
    DateTime: string[],
    orderType: number,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<ExpensesGetAllPagedResultDto> {
    let _url = this.baseUrl + "/api/services/app/Expenses/GetAll";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      _url += "?Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (storageCode !== undefined)
      _url += "Storage=" + encodeURIComponent("" + storageCode) + "&";
    if (DateTime !== undefined) {
      DateTime.forEach((element) => {
        _url += "DateTime=" + encodeURIComponent("" + element) + "&";
      });
    }
    if (orderType !== 0)
      _url += "OrderStatus=" + encodeURIComponent("" + orderType) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      _url += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      _url += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";

    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", _url, _options)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<ExpensesGetAllPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ExpensesGetAllPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<ExpensesGetAllPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExpensesGetAllPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ExpensesGetAllPagedResultDto>(<any>null);
  }
}
//#endregion
//#endregion
//#region Retail service
@Injectable()
export class RetailService {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  create(body: RetailInputDto | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/Retail/AddNew";
    _url = _url.replace(/[?&]$/, "");

    const _content = JSON.stringify(body);

    let _options: any = {
      body: _content,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
      }),
    };

    return this.http
      .request("post", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processAdd(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processAdd(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(_response));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processAdd(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }

    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            Headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  update(body: RetailInputDto | undefined): Observable<RetailInputDto> {
    let url_ = this.baseUrl + "/api/services/app/Retail/Update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(<any>response_);
            } catch (e) {
              return <Observable<RetailInputDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<RetailInputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<RetailInputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RetailInputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RetailInputDto>(<any>null);
  }

  updateOrder(
    body: RetailInputDto | undefined
  ): Observable<RetailInputDto> {
    let url_ = this.baseUrl + "/api/services/app/Retail/UpdateOrder";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json-patch+json",
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("put", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateOrder(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateOrder(<any>response_);
            } catch (e) {
              return <Observable<RetailInputDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<RetailInputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processUpdateOrder(
    response: HttpResponseBase
  ): Observable<RetailInputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RetailInputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RetailInputDto>(<any>null);
  }

  get(id: string | undefined): Observable<RetailOutputDto> {
    let url_ = this.baseUrl + "/api/services/app/Retail/Get?";
    if (id === null) throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(<any>response_);
            } catch (e) {
              return <Observable<RetailOutputDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RetailOutputDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<RetailOutputDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RetailOutputDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RetailOutputDto>(<any>null);
  }

  getCustomerSelect(): Observable<ListOfCustomer> {
    let url_ = this.baseUrl + "/api/services/app/ExportImport/GetCustomerList";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCustomerSelect(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCustomerSelect(<any>response_);
            } catch (e) {
              return <Observable<ListOfCustomer>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<ListOfCustomer>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetCustomerSelect(
    response: HttpResponseBase
  ): Observable<ListOfCustomer> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ListOfCustomer.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<ListOfCustomer>(<any>null);
  }

  getRandomCode(): Observable<string> {
    let url_ = this.baseUrl + "/api/services/app/ExportImport/GetRandomCode";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRandomCode(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRandomCode(<any>response_);
            } catch (e) {
              return <Observable<string>>(<any>_observableThrow(e));
            }
          } else return <Observable<string>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetRandomCode(
    response: HttpResponseBase
  ): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<string>(<any>null);
  }

  delete(id: string | undefined): Observable<void> {
    let _url = this.baseUrl + "/api/services/app/ExportImport/Delete?";
    if (id === null) throw new Error("The parameter 'id' cannot be null");
    else if (id !== undefined)
      _url += "Id=" + encodeURIComponent("" + id) + "&";
    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({}),
    };

    return this.http
      .request("delete", _url, _options)
      .pipe(
        _observableMergeMap((_response: any) => {
          return this.processDelete(_response);
        })
      )
      .pipe(
        _observableCatch((_response: any) => {
          if (_response instanceof HttpResponseBase) {
            try {
              return this.processDelete(<any>_response);
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(_response));
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  getCustomer(id: string): Observable<RetailCustomerDto> {
    let url_ = this.baseUrl + "/api/services/app/Retail/GetCustomer?";
    if (id === null) throw new Error("The parameter 'id' cannot be null");
    else if (id !== undefined)
      url_ += "PhoneNumber=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCustomer(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCustomer(<any>response_);
            } catch (e) {
              return <Observable<RetailCustomerDto>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<RetailCustomerDto>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetCustomer(
    response: HttpResponseBase
  ): Observable<RetailCustomerDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RetailCustomerDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RetailCustomerDto>(<any>null);
  }

  getProduct(
    keyword: string,
    storageId: string,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<RetailPagedResult> {
    let url_ = this.baseUrl + "/api/services/app/ExportImport/GetProduct?";
    if (storageId !== undefined)
      url_ += "StorageId=" + encodeURIComponent("" + storageId) + "&";
    if (keyword !== undefined)
      url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";

    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProduct(<any>response_);
            } catch (e) {
              return <Observable<RetailPagedResult>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RetailPagedResult>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetProduct(
    response: HttpResponseBase
  ): Observable<RetailPagedResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RetailPagedResult.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RetailPagedResult>(<any>null);
  }

  getUser(): Observable<LookUpTableList> {
    let url_ = this.baseUrl + "/api/services/app/ExportImport/GetCreator";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUser(<any>response_);
            } catch (e) {
              return <Observable<LookUpTableList>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<LookUpTableList>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetUser(
    response: HttpResponseBase
  ): Observable<LookUpTableList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = LookUpTableList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<LookUpTableList>(<any>null);
  }

  getAll(
    keyword: string | undefined,
    storageCode: string,
    DateTime: string[],
    orderType: number,
    skipCount: number | undefined,
    maxResultCount: number | undefined
  ): Observable<RetailGetAllPagedResultDto> {
    let _url = this.baseUrl + "/api/services/app/Retail/GetAll";
    if (keyword === null)
      throw new Error("The parameter 'keyword' cannot be null.");
    else if (keyword !== undefined)
      _url += "?Keyword=" + encodeURIComponent("" + keyword) + "&";
    if (storageCode !== undefined)
      _url += "Storage=" + encodeURIComponent("" + storageCode) + "&";
    if (DateTime !== undefined) {
      DateTime.forEach((element) => {
        _url += "DateTime=" + encodeURIComponent("" + element) + "&";
      });
    }
    if (orderType !== 0)
      _url += "OrderStatus=" + encodeURIComponent("" + orderType) + "&";
    if (skipCount === null)
      throw new Error("The parameter 'skipCount' cannot be null.");
    else if (skipCount !== undefined)
      _url += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
    if (maxResultCount === null)
      throw new Error("The parameter 'maxResultCount' cannot be null.");
    else if (maxResultCount !== undefined)
      _url += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";

    _url = _url.replace(/[?&]$/, "");

    let _options: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", _url, _options)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(<any>response_);
            } catch (e) {
              return <Observable<RetailGetAllPagedResultDto>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<RetailGetAllPagedResultDto>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAll(
    response: HttpResponseBase
  ): Observable<RetailGetAllPagedResultDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RetailGetAllPagedResultDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<RetailGetAllPagedResultDto>(<any>null);
  }
}
//#endregion
//#region SumaryService
@Injectable()
export class SumaryServiceProxy {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  GetRevenueStructure(date: string): Observable<DatasetDtoList> {
    let url_ = this.baseUrl + "/api/services/app/Sumary/GetRevenueStructure?";
    if (date === null) throw new Error("The parameter 'date' cannot be null.");
    else if (date !== undefined)
      url_ += "date=" + encodeURIComponent("" + date) + "&";

    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRevenueStructure(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRevenueStructure(<any>response_);
            } catch (e) {
              return <Observable<DatasetDtoList>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<DatasetDtoList>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetRevenueStructure(
    response: HttpResponseBase
  ): Observable<DatasetDtoList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DatasetDtoList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<DatasetDtoList>(<any>null);
  }
  
  GetProductSale(date: string): Observable<DatasetDtoList> {
    let url_ = this.baseUrl + "/api/services/app/Sumary/GetProductSales?";
    if (date === null) throw new Error("The parameter 'date' cannot be null.");
    else if (date !== undefined)
      url_ += "date=" + encodeURIComponent("" + date) + "&";

    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProductSale(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProductSale(<any>response_);
            } catch (e) {
              return <Observable<DatasetDtoList>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<DatasetDtoList>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetProductSale(
    response: HttpResponseBase
  ): Observable<DatasetDtoList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DatasetDtoList.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<DatasetDtoList>(<any>null);
  }
  
  GetAllSales(date: string): Observable<number> {
    let url_ = this.baseUrl + "/api/services/app/Sumary/GetAllSales?";
    if (date === null) throw new Error("The parameter 'date' cannot be null.");
    else if (date !== undefined)
      url_ += "date=" + encodeURIComponent("" + date) + "&";

    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        Accept: "text/plain",
      }),
    };

    return this.http
      .request("get", url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllSales(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllSales(<any>response_);
            } catch (e) {
              return <Observable<number>>(<any>_observableThrow(e));
            }
          } else return <Observable<number>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAllSales(
    response: HttpResponseBase
  ): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ""
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200;
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            "An unexpected server error occurred.",
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<number>(<any>null);
  }
}
//#endregion


//#region my Dto interface
export interface IStorageProductDto {
  productCode: string;
  productName: string;
  unit: string;
  quantity: number;
}

export interface IStorageOutPutDto {
  storageCode: string;
  storageName: string;
  address: string;
  description: string;
  products: StorageProduct[];
}

export interface IStorageInput {
  storageCode: string;
  storageName: string;
  structureId: string;
  address: string;
  description: string;
}

export interface IStorageForUpdate {
  storageCode: string;
  storageName: string;
  structureId: string;
  address: string;
  description: string;
}

export interface IStorageGetAllDto {
  storageCode: string;
  storageName: string;
  unit: string;
  address: string;
  productQuantity: number;
  creationTime: moment.Moment;
  lastDateModified: moment.Moment;
  username: string;
}

export interface IListStorageGetAllDto {
  storageCode: string;
  storageName: string;
  productQuantity: number;
  address: string;
  children: GetAllStorageDto[] | undefined;
}

export interface IStorageGetAllPagedResultDto {
  items: ListStorageGetAllDto[] | undefined;
  totalCount: number;
}

export interface IStorageProduct {
  productCode: string;
  productName: string;
  unit: string;
  quantity: number;
  location: string;
}

export interface ICategoryOutputDto {
  categoryCode: string;
  categoryName: string;
  description: string;
  subCategories: string[];
}

export interface ICategoryInputDto {
  categoryCode: string;
  categoryName: string;
  description: string;
  subCategories: string[];
}

export interface ICategoryGetAllDto {
  categoryCode: string;
  categoryName: string;
  creationTime: moment.Moment;
  lastModifiedDate: moment.Moment;
  username: string;
}

export interface ICategoryPagedResultInputDto {
  items: GetAllCategoryDto[] | undefined;
  totalCount: number;
}

export interface IStorageProductDetail {
  storageProductId: number;
  storageCode: string;
  storageName: string;
  quantity: number;
  productLocation: string;
}

export interface IProductForUpdate {
  productCode: string;
  productName: string;
  productDescription: string;
  productDetail: string;
  price: number;
  categoryId: string;
  subCategoryId: string;
  unit: string;
}

export interface IProductGetAllDto {
  productCode: string;
  productName: string;
  categoryName: string;
  price: number;
  unit: string;
  quantity: number;
  creationTime: moment.Moment;
  lastDateModified: moment.Moment;
  username: string;
}

export interface ISubcategoryProduct {
  subcategoryId: number;
  subcategoryName: string;
}

export interface IProductInputDto {
  productCode: string;
  productName: string;
  productDescription: string;
  productDetail: string;
  price: number;
  categoryId: string;
  subCategoryId: string;
  unit: string;
  storages: StorageProductDetail[];
}

export interface IProductOutputDto {
  productCode: string;
  productName: string;
  productDescription: string;
  productDetail: string;
  price: number;
  categoryId: string;
  subCategoryId: string;
  unit: string;
  storages: StorageProductDetail[];
}

export interface IProductStorageDto {
  storageCode: string;
  productQuantity: number;
  productLocation: string;
  description: string;
}

export interface IProductGetAllPagedResultDto {
  items: ProductGetAllDto[] | undefined;
  totalCount: number;
}

export interface ITestDto {
  testVarible: number;
}

export interface ITestInput {
  testVarible: number;
}

export interface ITestDtoListResultDto {
  items: TestDto[] | undefined;
}

export interface IGetAllTestDtoPagedResultDto {
  items: GetAllTestDto[] | undefined;
  totalCount: number;
}

export interface IExportImportProductDto {
  productId: string;
  productName: string;
  storageId: string;
  storageInputId: string;
  quantity: number;
  price: number;
  unit: string;
  finalPrice: number;
  totalPrice: number;
}

export interface IExportImportOutputDto {
  exportImportCode: string;
  nameOfReceiver: string;
  employeeDelivery: string;
  orderStatus: number;
  structureId: string;
  orderCreator: string;
  discount: number;
  orderType: number;
  receiveAddress: string;
  products: ExportImportProductDto[];
  totalPrice: number;
}

export interface IGetAllExportImportDto {
  exportImportCode: string;
  nameOfReceiver: string;
  orderCreator: string;
  orderStatus: number;
  storageName: string;
  structureName: string;
  discount: number;
  address: string;
  orderType: number;
  totalPrice: number;
  creationTime: Date;
  lastModifiedDate: Date;
  username: string;
}

export interface IGetAllExportImportPagedResult {
  items: GetAllExportImportDto[] | undefined;
  totalCount: number;
}

export interface IProductExportImportPagedResult {
  items: ExportImportProductDto[] | undefined;
  totalCount: number;
}

export interface IExportImportInputDto {
  exportImportCode: string;
  orderCreator: string;
  employeeDelivery: string;
  customer: CustomerDto;
  structureId: string;
  products: ExportImportProductDto[];
  discount: number;
  productLocation: string;
  nameOfExport: string;
  totalPrice: number;
  description: string;
}

export interface ICustomerListDto {
  code: string;
  name: string;
}

export interface IListOfCustomer {
  items: CustomerListDto[];
}
//#endregion

//#region Implement dto interface
export class CustomerListDto implements ICustomerListDto {
  code: string;
  name: string;

  constructor(data?: ICustomerListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data: any) {
    if (_data) {
      this.code = _data["code"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): CustomerListDto {
    data = typeof data === "object" ? data : {};
    let result = new CustomerListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["code"] = this.code;
    data["name"] = this.name;
    return data;
  }

  clone(): CustomerListDto {
    const json = this.toJSON();
    let result = new CustomerListDto();
    result.init(json);
    return result;
  }
}

export class ListOfCustomer implements IListOfCustomer {
  items: CustomerListDto[];

  constructor(data?: IListOfCustomer) {
    if (data) {
      this.items = data.items;
    }
  }

  init(_data: any) {
    if (_data) {
      this.items = _data["items"];
    }
  }

  static fromJS(data: any): ListOfCustomer {
    data = typeof data === "object" ? data : {};
    let result = new ListOfCustomer();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["items"] = this.items;
    return data;
  }

  clone(): ListOfCustomer {
    const json = this.toJSON();
    let result = new ListOfCustomer();
    result.init(json);
    return result;
  }
}

export class ExportImportInput implements IExportImportInputDto {
  exportImportCode: string;
  orderCreator: string;
  employeeDelivery: string;
  orderStatus: number;
  orderType: number;
  customer: CustomerDto;
  structureId: string;
  products: ExportImportProductDto[];
  discount: number;
  productLocation: string;
  nameOfExport: string;
  totalPrice: number;
  description: string;

  constructor(data?: IExportImportInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data: any) {
    if (_data) {
      this.exportImportCode = _data["exportImportCode"];
      this.orderCreator = _data["orderCreator"];
      this.employeeDelivery = _data["employeeDelivery"];
      this.orderStatus = _data["orderStatus"];
      this.orderType = _data["orderType"];
      this.structureId = _data["structureId"];
      this.customer = _data["customer"];
      this.products = _data["products"];
      this.discount = _data["discount"];
      this.nameOfExport = _data["nameOfExport"];
      this.productLocation = _data["productLocation"];
      this.totalPrice = _data["totalPrice"];
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): ExportImportInput {
    data = typeof data === "object" ? data : {};
    let result = new ExportImportInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["exportImportCode"] = this.exportImportCode;
    data["orderCreator"] = this.orderCreator;
    data["employeeDelivery"] = this.employeeDelivery;
    data["orderStatus"] = this.orderStatus;
    data["orderType"] = this.orderType;
    data["structureId"] = this.structureId;
    data["customer"] = this.customer;
    data["products"] = this.products;
    data["discount"] = this.discount;
    data["nameOfExport"] = this.nameOfExport;
    data["productLocation"] = this.productLocation;
    data["totalPrice"] = this.totalPrice;
    data["description"] = this.description;
    return data;
  }
}

export class ExportImportOutputDto implements IExportImportOutputDto {
  exportImportCode: string;
  nameOfReceiver: string;
  employeeDelivery: string;
  orderCreator: string;
  structureId: string;
  orderStatus: number;
  orderType: number;
  receiveAddress: string;
  customer: CustomerDto;
  products: ExportImportProductDto[];
  discount: number;
  nameOfExport: string;
  totalPrice: number;

  constructor(data?: IExportImportOutputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data: any) {
    if (_data) {
      this.exportImportCode = _data["exportImportCode"];
      this.nameOfReceiver = _data["nameOfReceiver"];
      this.orderCreator = _data["orderCreator"];
      this.employeeDelivery = _data["employeeDelivery"];
      this.orderStatus = _data["orderStatus"];
      this.orderType = _data["orderType"];
      this.structureId = _data["structureId"];
      this.receiveAddress = _data["receiveAddress"];
      this.products = _data["products"];
      this.customer = _data["customer"];
      this.nameOfExport = _data["nameOfExport"];
      this.totalPrice = _data["totalPrice"];
      this.discount = _data["discount"];
    }
  }

  static fromJS(data: any): ExportImportOutputDto {
    data = typeof data === "object" ? data : {};
    let result = new ExportImportOutputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["exportImportCode"] = this.exportImportCode;
    data["nameOfReceiver"] = this.nameOfReceiver;
    data["orderCreator"] = this.orderCreator;
    data["structureId"] = this.structureId;
    data["employeeDelivery"] = this.employeeDelivery;
    data["orderStatus"] = this.orderStatus;
    data["orderType"] = this.orderType;
    data["receiveAddress"] = this.receiveAddress;
    data["products"] = this.products;
    data["customer"] = this.customer;
    data["nameOfExport"] = this.nameOfExport;
    data["totalPrice"] = this.totalPrice;
    data["discount"] = this.discount;
    return data;
  }

  clone(): ExportImportOutputDto {
    const json = this.toJSON();
    let result = new ExportImportOutputDto();
    result.init(json);
    return result;
  }
}
export class GetAllExportImportPagedResult
  implements IGetAllExportImportPagedResult
{
  items: GetAllExportImportDto[] | undefined;
  totalCount: number;

  constructor(data?: IGetAllExportImportPagedResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(GetAllExportImportDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): GetAllExportImportPagedResult {
    data = typeof data === "object" ? data : {};
    let result = new GetAllExportImportPagedResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): GetAllExportImportPagedResult {
    const json = this.toJSON();
    let result = new GetAllExportImportPagedResult();
    result.init(json);
    return result;
  }
}

export class ExportImportPagedResult
  implements IProductExportImportPagedResult
{
  items: ExportImportProductDto[] | undefined;
  totalCount: number;

  constructor(data?: IProductExportImportPagedResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(ExportImportProductDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): ExportImportPagedResult {
    data = typeof data === "object" ? data : {};
    let result = new ExportImportPagedResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): ExportImportPagedResult {
    const json = this.toJSON();
    let result = new ExportImportPagedResult();
    result.init(json);
    return result;
  }
}

export class GetAllExportImportDto implements IGetAllExportImportDto {
  exportImportCode: string;
  nameOfReceiver: string;
  orderCreator: string;
  orderStatus: number;
  storageName: string;
  structureName: string;
  address: string;
  orderType: number;
  totalPrice: number;
  discount: number;
  creationTime: Date;
  lastModifiedDate: Date;
  username: string;
  nameOfExport: string;

  constructor(data?: IGetAllExportImportDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data: any) {
    if (_data) {
      this.exportImportCode = _data["exportImportCode"];
      this.nameOfReceiver = _data["nameOfReceiver"];
      this.orderCreator = _data["orderCreator"];
      this.orderStatus = _data["orderStatus"];
      this.storageName = _data["storageName"];
      this.structureName = _data["structureName"];
      this.address = _data["address"];
      this.orderType = _data["orderType"];
      this.discount = _data["discount"];
      this.totalPrice = _data["totalPrice"];
      this.creationTime = _data["creationTime"];
      this.lastModifiedDate = _data["lastModifiedDate"];
      this.username = _data["username"];
      this.nameOfExport = _data["nameOfExport"];
    }
  }

  static fromJS(data: any): GetAllExportImportDto {
    data = typeof data === "object" ? data : {};
    let result = new GetAllExportImportDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["exportImportCode"] = this.exportImportCode;
    data["nameOfReceiver"] = this.nameOfReceiver;
    data["orderCreator"] = this.orderCreator;
    data["orderStatus"] = this.orderStatus;
    data["storageName"] = this.storageName;
    data["structureName"] = this.structureName;
    data["address"] = this.address;
    data["orderType"] = this.orderType;
    data["discount"] = this.discount;
    data["totalPrice"] = this.totalPrice;
    data["creationTime"] = this.creationTime;
    data["lastModifiedDate"] = this.lastModifiedDate;
    data["username"] = this.username;
    data["nameOfExport"] = this.nameOfExport;
    return data;
  }

  clone(): GetAllExportImportDto {
    const json = this.toJSON();
    let result = new GetAllExportImportDto();
    result.init(json);
    return result;
  }
}

export class ExportImportProductDto implements IExportImportProductDto {
  productId: string;
  productName: string;
  storageId: string;
  storageInputId: string;
  quantity: number;
  price: number;
  unit: string;
  location: string;
  finalPrice: number;
  totalPrice: number;

  constructor(data?: IExportImportProductDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data: any) {
    if (_data) {
      this.productId = _data["productId"];
      this.productName = _data["productName"];
      this.quantity = _data["quantity"];
      this.storageId = _data["storageId"];
      this.storageInputId = _data["storageInputId"];
      this.price = _data["price"];
      this.unit = _data["unit"];
      this.location = _data["location"];
      this.finalPrice = _data["finalPrice"];
      this.totalPrice = _data["totalPrice"];
    }
  }

  static fromJS(data: any): ExportImportProductDto {
    data = typeof data === "object" ? data : {};
    let result = new ExportImportProductDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["productId"] = this.productId;
    data["productName"] = this.productName;
    data["quantity"] = this.quantity;
    data["storageId"] = this.storageId;
    data["storageInputId"] = this.storageInputId;
    data["price"] = this.price;
    data["unit"] = this.unit;
    data["location"] = this.location;
    data["finalPrice"] = this.finalPrice;
    data["totalPrice"] = this.totalPrice;
    return data;
  }

  clone(): ExportImportProductDto {
    const json = this.toJSON();
    let result = new ExportImportProductDto();
    result.init(json);
    return result;
  }
}

export class CustomerDto {
  customerCode: number;
  customerName: string;
  customerPhone: string;
  customerAdress: string;
  discount: number;

  constructor(data?: CustomerDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data: any) {
    if (_data) {
      this.customerCode = _data["customerCode"];
      this.customerName = _data["customerName"];
      this.customerPhone = _data["customerPhone"];
      this.customerAdress = _data["customerAdress"];
      this.discount = _data["discount"];
    }
  }

  static fromJS(data: any): CustomerDto {
    data = typeof data === "object" ? data : {};
    let result = new CustomerDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["customerCode"] = this.customerCode;
    data["customerName"] = this.customerName;
    data["customerPhone"] = this.customerPhone;
    data["customerAdress"] = this.customerAdress;
    data["discount"] = this.discount;
    return data;
  }

  clone(): CustomerDto {
    const json = this.toJSON();
    let result = new CustomerDto();
    result.init(json);
    return result;
  }
}

export class GetAllCategoryDto implements ICategoryGetAllDto {
  categoryCode: string;
  categoryName: string;
  creationTime: moment.Moment;
  lastModifiedDate: moment.Moment;
  username: string;

  constructor(data?: ICategoryGetAllDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data: any) {
    if (_data) {
      this.categoryCode = _data["categoryCode"];
      this.categoryName = _data["categoryName"];
      this.creationTime = _data["creationTime"];
      this.lastModifiedDate = _data["lastModifiedDate"];
      this.username = _data["username"];
    }
  }

  static fromJS(data: any): GetAllCategoryDto {
    data = typeof data === "object" ? data : {};
    let result = new GetAllCategoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storageCode"] = this.categoryCode;
    data["storageName"] = this.categoryName;
    data["creationTime"] = this.creationTime;
    data["lastModifiedDate"] = this.lastModifiedDate;
    data["username"] = this.username;
    return data;
  }

  clone(): GetAllTestDto {
    const json = this.toJSON();
    let result = new GetAllTestDto();
    result.init(json);
    return result;
  }
}

export class CategoryInput implements ICategoryInputDto {
  categoryCode: string;
  categoryName: string;
  description: string;
  subCategories: string[];

  constructor(data?: CategoryInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data: any) {
    if (_data) {
      this.categoryCode = _data["categoryCode"];
      this.categoryName = _data["categoryName"];
      this.description = _data["description"];
      this.subCategories = _data["subCategories"];
    }
  }

  static fromJS(data: any): CategoryInput {
    data = typeof data === "object" ? data : {};
    let result = new CategoryInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["categoryCode"] = this.categoryCode;
    data["categoryName"] = this.categoryName;
    data["description"] = this.description;
    data["subCategories"] = this.subCategories;
    return data;
  }
}

export class CategoryOutputDto implements ICategoryOutputDto {
  categoryCode: string;
  categoryName: string;
  description: string;
  subCategories: string[];

  constructor(data?: ICategoryOutputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data: any) {
    if (_data) {
      this.categoryCode = _data["categoryCode"];
      this.categoryName = _data["categoryName"];
      this.description = _data["description"];
      this.subCategories = _data["subCategories"];
    }
  }

  static fromJS(data: any): CategoryOutputDto {
    data = typeof data === "object" ? data : {};
    let result = new CategoryOutputDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["categoryCode"] = this.categoryCode;
    data["categoryName"] = this.categoryName;
    data["description"] = this.description;
    data["subCategories"] = this.subCategories;
    return data;
  }

  clone(): CategoryOutputDto {
    const json = this.toJSON();
    let result = new CategoryOutputDto();
    result.init(json);
    return result;
  }
}

export class GetAllCategoryPagedResultDto
  implements ICategoryPagedResultInputDto
{
  items: GetAllCategoryDto[] | undefined;
  totalCount: number;

  constructor(data?: ICategoryPagedResultInputDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(GetAllCategoryDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): GetAllCategoryPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new GetAllCategoryPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): GetAllCategoryPagedResultDto {
    const json = this.toJSON();
    let result = new GetAllCategoryPagedResultDto();
    result.init(json);
    return result;
  }
}

export class StorageInput implements IStorageInput {
  storageCode: string;
  storageName: string;
  structureId: string;
  address: string;
  description: string;

  constructor(data?: IStorageInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data: any) {
    if (_data) {
      this.storageCode = _data["storageCode"];
      this.storageName = _data["storageName"];
      this.structureId = _data["structureId"];
      this.address = _data["address"];
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): StorageInput {
    data = typeof data === "object" ? data : {};
    let result = new StorageInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storageCode"] = this.storageCode;
    data["storageName"] = this.storageName;
    data["structureId"] = this.structureId;
    data["address"] = this.address;
    data["description"] = this.description;
    return data;
  }
}

export class ListStorageGetAllDto implements IListStorageGetAllDto {
  storageCode: string;
  storageName: string;
  productQuantity: number;
  address: string;
  children: GetAllStorageDto[] | undefined;
  
  constructor(data?: IListStorageGetAllDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data: any) {
    if (_data) {
      this.storageCode = _data["storageCode"];
      this.storageName = _data["storageName"];
      this.productQuantity = _data["productQuantity"];
      this.address = _data["address"];
      this.children = _data["children"];
    }
  }

  static fromJS(data: any): ListStorageGetAllDto {
    data = typeof data === "object" ? data : {};
    let result = new ListStorageGetAllDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storageCode"] = this.storageCode;
    data["storageName"] = this.storageName;
    data["productQuantity"] = this.productQuantity;
    data["address"] = this.address;
    data["children"] = this.children;
    return data;
  }

  clone(): ListStorageGetAllDto {
    const json = this.toJSON();
    let result = new ListStorageGetAllDto();
    result.init(json);
    return result;
  }
}

export class GetAllStorageDto implements IStorageGetAllDto {
  storageCode: string;
  storageName: string;
  unit: string;
  address: string;
  creationTime: moment.Moment;
  productQuantity: number;
  lastDateModified: moment.Moment;
  username: string;

  constructor(data?: IStorageGetAllDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data: any) {
    if (_data) {
      this.storageCode = _data["storageCode"];
      this.storageName = _data["storageName"];
      this.unit = _data["unit"];
      this.address = _data["address"];
      this.creationTime = _data["creationTime"];
      this.productQuantity = _data["productQuantity"];
      this.lastDateModified = _data["lastDateModified"];
      this.username = _data["username"];
    }
  }

  static fromJS(data: any): GetAllStorageDto {
    data = typeof data === "object" ? data : {};
    let result = new GetAllStorageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storageCode"] = this.storageCode;
    data["storageName"] = this.storageName;
    data["unit"] = this.unit;
    data["address"] = this.address;
    data["creationTime"] = this.creationTime;
    data["productQuantity"] = this.productQuantity;
    data["lastDateModified"] = this.lastDateModified;
    data["username"] = this.username;
    return data;
  }

  clone(): GetAllTestDto {
    const json = this.toJSON();
    let result = new GetAllTestDto();
    result.init(json);
    return result;
  }
}

export class GetAllStoragePagedResultDto
  implements IStorageGetAllPagedResultDto
{
  items: ListStorageGetAllDto[] | undefined;
  totalCount: number;

  constructor(data?: IStorageGetAllPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(ListStorageGetAllDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): GetAllStoragePagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new GetAllStoragePagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): GetAllStoragePagedResultDto {
    const json = this.toJSON();
    let result = new GetAllStoragePagedResultDto();
    result.init(json);
    return result;
  }
}

export class StorageForUpdate implements IStorageForUpdate {
  storageCode: string;
  storageName: string;
  structureId: string;
  address: string;
  description: string;

  constructor(data?: IStorageForUpdate) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.storageCode = _data["storageCode"];
      this.storageName = _data["storageName"];
      this.structureId = _data["structureId"];
      this.address = _data["address"];
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): StorageForUpdate {
    data = typeof data === "object" ? data : {};
    let result = new StorageForUpdate();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storageCode"] = this.storageCode;
    data["storageName"] = this.storageName;
    data["structureId"] = this.structureId;
    data["address"] = this.address;
    data["description"] = this.description;
    return data;
  }

  clone(): StorageForUpdate {
    const json = this.toJSON();
    let result = new StorageForUpdate();
    result.init(json);
    return result;
  }
}

export class StorageOutPutDto implements IStorageOutPutDto {
  storageCode: string;
  storageName: string;
  address: string;
  description: string;
  products: StorageProduct[];

  constructor(data?: IStorageOutPutDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.storageCode = _data["storageCode"];
      this.storageName = _data["storageName"];
      this.address = _data["address"];
      this.description = _data["description"];
      this.products = _data["products"];
    }
  }

  static fromJS(data: any): StorageOutPutDto {
    data = typeof data === "object" ? data : {};
    let result = new StorageOutPutDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["storageCode"] = this.storageCode;
    data["storageName"] = this.storageName;
    data["address"] = this.address;
    data["description"] = this.description;
    data["products"] = this.products;
    return data;
  }

  clone(): StorageOutPutDto {
    const json = this.toJSON();
    let result = new StorageOutPutDto();
    result.init(json);
    return result;
  }
}

//Product
export class TestInput implements ITestInput {
  testVarible: number | undefined;

  constructor(data?: ITestInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data: any) {
    if (_data) {
      this.testVarible = _data["testVarible"];
    }
  }

  static fromJS(data: any): TestInput {
    data = typeof data === "object" ? data : {};
    let result = new TestInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["testVarible"] = this.testVarible;
    return data;
  }
}

export class TestDtoListResultDto implements ITestDtoListResultDto {
  items: TestDto[] | undefined;

  constructor(data?: ITestDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(TestDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): TestDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new TestDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): TestDtoListResultDto {
    const json = this.toJSON();
    let result = new TestDtoListResultDto();
    result.init(json);
    return result;
  }
}

export class TestDto implements ITestDto {
  testVarible: number;

  constructor(data?: ITestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.testVarible = _data["testVarible"];
    }
  }

  static fromJS(data: any): TestDto {
    data = typeof data === "object" ? data : {};
    let result = new TestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["testVarible"] = this.testVarible;
    return data;
  }

  clone(): TestDto {
    const json = this.toJSON();
    let result = new TestDto();
    result.init(json);
    return result;
  }
}

export class GetAllTestDto implements ITestDto {
  testVarible: number;

  constructor(data?: ITestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.testVarible = _data["testVarible"];
    }
  }

  static fromJS(data: any): GetAllTestDto {
    data = typeof data === "object" ? data : {};
    let result = new GetAllTestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["testVarible"] = this.testVarible;
    return data;
  }

  clone(): GetAllTestDto {
    const json = this.toJSON();
    let result = new GetAllTestDto();
    result.init(json);
    return result;
  }
}

export class GetAllTestDtoPagedResultDto
  implements IGetAllTestDtoPagedResultDto
{
  items: GetAllTestDto[] | undefined;
  totalCount: number;

  constructor(data?: IGetAllTestDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(GetAllTestDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): GetAllTestDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new GetAllTestDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): GetAllTestDtoPagedResultDto {
    const json = this.toJSON();
    let result = new GetAllTestDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

//#endregion

//#region framework dto
export class ApplicationInfoDto implements IApplicationInfoDto {
  version: string | undefined;
  releaseDate: moment.Moment;
  features: { [key: string]: boolean } | undefined;

  constructor(data?: IApplicationInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.version = _data["version"];
      this.releaseDate = _data["releaseDate"]
        ? moment(_data["releaseDate"].toString())
        : <any>undefined;
      if (_data["features"]) {
        this.features = {} as any;
        for (let key in _data["features"]) {
          if (_data["features"].hasOwnProperty(key))
            (<any>this.features)[key] = _data["features"][key];
        }
      }
    }
  }

  static fromJS(data: any): ApplicationInfoDto {
    data = typeof data === "object" ? data : {};
    let result = new ApplicationInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["version"] = this.version;
    data["releaseDate"] = this.releaseDate
      ? this.releaseDate.toISOString()
      : <any>undefined;
    if (this.features) {
      data["features"] = {};
      for (let key in this.features) {
        if (this.features.hasOwnProperty(key))
          (<any>data["features"])[key] = (<any>this.features)[key];
      }
    }
    return data;
  }

  clone(): ApplicationInfoDto {
    const json = this.toJSON();
    let result = new ApplicationInfoDto();
    result.init(json);
    return result;
  }
}

export interface IApplicationInfoDto {
  version: string | undefined;
  releaseDate: moment.Moment;
  features: { [key: string]: boolean } | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
  userNameOrEmailAddress: string;
  password: string;
  rememberClient: boolean;

  constructor(data?: IAuthenticateModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
      this.password = _data["password"];
      this.rememberClient = _data["rememberClient"];
    }
  }

  static fromJS(data: any): AuthenticateModel {
    data = typeof data === "object" ? data : {};
    let result = new AuthenticateModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
    data["password"] = this.password;
    data["rememberClient"] = this.rememberClient;
    return data;
  }

  clone(): AuthenticateModel {
    const json = this.toJSON();
    let result = new AuthenticateModel();
    result.init(json);
    return result;
  }
}

export interface IAuthenticateModel {
  userNameOrEmailAddress: string;
  password: string;
  rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  userId: number;

  constructor(data?: IAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data["accessToken"];
      this.encryptedAccessToken = _data["encryptedAccessToken"];
      this.expireInSeconds = _data["expireInSeconds"];
      this.userId = _data["userId"];
    }
  }

  static fromJS(data: any): AuthenticateResultModel {
    data = typeof data === "object" ? data : {};
    let result = new AuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["accessToken"] = this.accessToken;
    data["encryptedAccessToken"] = this.encryptedAccessToken;
    data["expireInSeconds"] = this.expireInSeconds;
    data["userId"] = this.userId;
    return data;
  }

  clone(): AuthenticateResultModel {
    const json = this.toJSON();
    let result = new AuthenticateResultModel();
    result.init(json);
    return result;
  }
}

export interface IAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  userId: number;
}

export class ChangePasswordDto implements IChangePasswordDto {
  currentPassword: string;
  newPassword: string;

  constructor(data?: IChangePasswordDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currentPassword = _data["currentPassword"];
      this.newPassword = _data["newPassword"];
    }
  }

  static fromJS(data: any): ChangePasswordDto {
    data = typeof data === "object" ? data : {};
    let result = new ChangePasswordDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["currentPassword"] = this.currentPassword;
    data["newPassword"] = this.newPassword;
    return data;
  }

  clone(): ChangePasswordDto {
    const json = this.toJSON();
    let result = new ChangePasswordDto();
    result.init(json);
    return result;
  }
}

export interface IChangePasswordDto {
  currentPassword: string;
  newPassword: string;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
  theme: string;

  constructor(data?: IChangeUiThemeInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.theme = _data["theme"];
    }
  }

  static fromJS(data: any): ChangeUiThemeInput {
    data = typeof data === "object" ? data : {};
    let result = new ChangeUiThemeInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["theme"] = this.theme;
    return data;
  }

  clone(): ChangeUiThemeInput {
    const json = this.toJSON();
    let result = new ChangeUiThemeInput();
    result.init(json);
    return result;
  }
}

export interface IChangeUiThemeInput {
  theme: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
  languageName: string;

  constructor(data?: IChangeUserLanguageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.languageName = _data["languageName"];
    }
  }

  static fromJS(data: any): ChangeUserLanguageDto {
    data = typeof data === "object" ? data : {};
    let result = new ChangeUserLanguageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["languageName"] = this.languageName;
    return data;
  }

  clone(): ChangeUserLanguageDto {
    const json = this.toJSON();
    let result = new ChangeUserLanguageDto();
    result.init(json);
    return result;
  }
}

export interface IChangeUserLanguageDto {
  languageName: string;
}

export class CreateRoleDto implements ICreateRoleDto {
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;

  constructor(data?: ICreateRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.normalizedName = _data["normalizedName"];
      this.description = _data["description"];
      if (Array.isArray(_data["grantedPermissions"])) {
        this.grantedPermissions = [] as any;
        for (let item of _data["grantedPermissions"])
          this.grantedPermissions.push(item);
      }
    }
  }

  static fromJS(data: any): CreateRoleDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateRoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["normalizedName"] = this.normalizedName;
    data["description"] = this.description;
    if (Array.isArray(this.grantedPermissions)) {
      data["grantedPermissions"] = [];
      for (let item of this.grantedPermissions)
        data["grantedPermissions"].push(item);
    }
    return data;
  }

  clone(): CreateRoleDto {
    const json = this.toJSON();
    let result = new CreateRoleDto();
    result.init(json);
    return result;
  }
}

export interface ICreateRoleDto {
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
  tenancyName: string;
  name: string;
  adminEmailAddress: string;
  connectionString: string | undefined;
  isActive: boolean;

  constructor(data?: ICreateTenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data["tenancyName"];
      this.name = _data["name"];
      this.adminEmailAddress = _data["adminEmailAddress"];
      this.connectionString = _data["connectionString"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): CreateTenantDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateTenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["tenancyName"] = this.tenancyName;
    data["name"] = this.name;
    data["adminEmailAddress"] = this.adminEmailAddress;
    data["connectionString"] = this.connectionString;
    data["isActive"] = this.isActive;
    return data;
  }

  clone(): CreateTenantDto {
    const json = this.toJSON();
    let result = new CreateTenantDto();
    result.init(json);
    return result;
  }
}

export interface ICreateTenantDto {
  tenancyName: string;
  name: string;
  adminEmailAddress: string;
  connectionString: string | undefined;
  isActive: boolean;
}

export class CreateUserDto implements ICreateUserDto {
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  roleNames: string[] | undefined;
  password: string;

  constructor(data?: ICreateUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userName = _data["userName"];
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.emailAddress = _data["emailAddress"];
      this.isActive = _data["isActive"];
      if (Array.isArray(_data["roleNames"])) {
        this.roleNames = [] as any;
        for (let item of _data["roleNames"]) this.roleNames.push(item);
      }
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): CreateUserDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateUserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["userName"] = this.userName;
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["emailAddress"] = this.emailAddress;
    data["isActive"] = this.isActive;
    if (Array.isArray(this.roleNames)) {
      data["roleNames"] = [];
      for (let item of this.roleNames) data["roleNames"].push(item);
    }
    data["password"] = this.password;
    return data;
  }

  clone(): CreateUserDto {
    const json = this.toJSON();
    let result = new CreateUserDto();
    result.init(json);
    return result;
  }
}

export interface ICreateUserDto {
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  roleNames: string[] | undefined;
  password: string;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
  authProvider: string;
  providerKey: string;
  providerAccessCode: string;

  constructor(data?: IExternalAuthenticateModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.authProvider = _data["authProvider"];
      this.providerKey = _data["providerKey"];
      this.providerAccessCode = _data["providerAccessCode"];
    }
  }

  static fromJS(data: any): ExternalAuthenticateModel {
    data = typeof data === "object" ? data : {};
    let result = new ExternalAuthenticateModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["authProvider"] = this.authProvider;
    data["providerKey"] = this.providerKey;
    data["providerAccessCode"] = this.providerAccessCode;
    return data;
  }

  clone(): ExternalAuthenticateModel {
    const json = this.toJSON();
    let result = new ExternalAuthenticateModel();
    result.init(json);
    return result;
  }
}

export interface IExternalAuthenticateModel {
  authProvider: string;
  providerKey: string;
  providerAccessCode: string;
}

export class ExternalAuthenticateResultModel
  implements IExternalAuthenticateResultModel
{
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  waitingForActivation: boolean;

  constructor(data?: IExternalAuthenticateResultModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data["accessToken"];
      this.encryptedAccessToken = _data["encryptedAccessToken"];
      this.expireInSeconds = _data["expireInSeconds"];
      this.waitingForActivation = _data["waitingForActivation"];
    }
  }

  static fromJS(data: any): ExternalAuthenticateResultModel {
    data = typeof data === "object" ? data : {};
    let result = new ExternalAuthenticateResultModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["accessToken"] = this.accessToken;
    data["encryptedAccessToken"] = this.encryptedAccessToken;
    data["expireInSeconds"] = this.expireInSeconds;
    data["waitingForActivation"] = this.waitingForActivation;
    return data;
  }

  clone(): ExternalAuthenticateResultModel {
    const json = this.toJSON();
    let result = new ExternalAuthenticateResultModel();
    result.init(json);
    return result;
  }
}

export interface IExternalAuthenticateResultModel {
  accessToken: string | undefined;
  encryptedAccessToken: string | undefined;
  expireInSeconds: number;
  waitingForActivation: boolean;
}

export class ExternalLoginProviderInfoModel
  implements IExternalLoginProviderInfoModel
{
  name: string | undefined;
  clientId: string | undefined;

  constructor(data?: IExternalLoginProviderInfoModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.clientId = _data["clientId"];
    }
  }

  static fromJS(data: any): ExternalLoginProviderInfoModel {
    data = typeof data === "object" ? data : {};
    let result = new ExternalLoginProviderInfoModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["clientId"] = this.clientId;
    return data;
  }

  clone(): ExternalLoginProviderInfoModel {
    const json = this.toJSON();
    let result = new ExternalLoginProviderInfoModel();
    result.init(json);
    return result;
  }
}

export interface IExternalLoginProviderInfoModel {
  name: string | undefined;
  clientId: string | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;

  constructor(data?: IFlatPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): FlatPermissionDto {
    data = typeof data === "object" ? data : {};
    let result = new FlatPermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    return data;
  }

  clone(): FlatPermissionDto {
    const json = this.toJSON();
    let result = new FlatPermissionDto();
    result.init(json);
    return result;
  }
}

export interface IFlatPermissionDto {
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
}

export class GetCurrentLoginInformationsOutput
  implements IGetCurrentLoginInformationsOutput
{
  application: ApplicationInfoDto;
  user: UserLoginInfoDto;
  tenant: TenantLoginInfoDto;

  constructor(data?: IGetCurrentLoginInformationsOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.application = _data["application"]
        ? ApplicationInfoDto.fromJS(_data["application"])
        : <any>undefined;
      this.user = _data["user"]
        ? UserLoginInfoDto.fromJS(_data["user"])
        : <any>undefined;
      this.tenant = _data["tenant"]
        ? TenantLoginInfoDto.fromJS(_data["tenant"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): GetCurrentLoginInformationsOutput {
    data = typeof data === "object" ? data : {};
    let result = new GetCurrentLoginInformationsOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["application"] = this.application
      ? this.application.toJSON()
      : <any>undefined;
    data["user"] = this.user ? this.user.toJSON() : <any>undefined;
    data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
    return data;
  }

  clone(): GetCurrentLoginInformationsOutput {
    const json = this.toJSON();
    let result = new GetCurrentLoginInformationsOutput();
    result.init(json);
    return result;
  }
}

export interface IGetCurrentLoginInformationsOutput {
  application: ApplicationInfoDto;
  user: UserLoginInfoDto;
  tenant: TenantLoginInfoDto;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
  role: RoleEditDto;
  permissions: FlatPermissionDto[] | undefined;
  grantedPermissionNames: string[] | undefined;

  constructor(data?: IGetRoleForEditOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.role = _data["role"]
        ? RoleEditDto.fromJS(_data["role"])
        : <any>undefined;
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"])
          this.permissions.push(FlatPermissionDto.fromJS(item));
      }
      if (Array.isArray(_data["grantedPermissionNames"])) {
        this.grantedPermissionNames = [] as any;
        for (let item of _data["grantedPermissionNames"])
          this.grantedPermissionNames.push(item);
      }
    }
  }

  static fromJS(data: any): GetRoleForEditOutput {
    data = typeof data === "object" ? data : {};
    let result = new GetRoleForEditOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["role"] = this.role ? this.role.toJSON() : <any>undefined;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item.toJSON());
    }
    if (Array.isArray(this.grantedPermissionNames)) {
      data["grantedPermissionNames"] = [];
      for (let item of this.grantedPermissionNames)
        data["grantedPermissionNames"].push(item);
    }
    return data;
  }

  clone(): GetRoleForEditOutput {
    const json = this.toJSON();
    let result = new GetRoleForEditOutput();
    result.init(json);
    return result;
  }
}

export interface IGetRoleForEditOutput {
  role: RoleEditDto;
  permissions: FlatPermissionDto[] | undefined;
  grantedPermissionNames: string[] | undefined;
}

export class Int64EntityDto implements IInt64EntityDto {
  id: number;

  constructor(data?: IInt64EntityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Int64EntityDto {
    data = typeof data === "object" ? data : {};
    let result = new Int64EntityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    return data;
  }

  clone(): Int64EntityDto {
    const json = this.toJSON();
    let result = new Int64EntityDto();
    result.init(json);
    return result;
  }
}

export interface IInt64EntityDto {
  id: number;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
  tenancyName: string;

  constructor(data?: IIsTenantAvailableInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenancyName = _data["tenancyName"];
    }
  }

  static fromJS(data: any): IsTenantAvailableInput {
    data = typeof data === "object" ? data : {};
    let result = new IsTenantAvailableInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["tenancyName"] = this.tenancyName;
    return data;
  }

  clone(): IsTenantAvailableInput {
    const json = this.toJSON();
    let result = new IsTenantAvailableInput();
    result.init(json);
    return result;
  }
}

export interface IIsTenantAvailableInput {
  tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
  state: TenantAvailabilityState;
  tenantId: number | undefined;

  constructor(data?: IIsTenantAvailableOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.state = _data["state"];
      this.tenantId = _data["tenantId"];
    }
  }

  static fromJS(data: any): IsTenantAvailableOutput {
    data = typeof data === "object" ? data : {};
    let result = new IsTenantAvailableOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["state"] = this.state;
    data["tenantId"] = this.tenantId;
    return data;
  }

  clone(): IsTenantAvailableOutput {
    const json = this.toJSON();
    let result = new IsTenantAvailableOutput();
    result.init(json);
    return result;
  }
}

export interface IIsTenantAvailableOutput {
  state: TenantAvailabilityState;
  tenantId: number | undefined;
}

export class PermissionDto implements IPermissionDto {
  id: number;
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;

  constructor(data?: IPermissionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): PermissionDto {
    data = typeof data === "object" ? data : {};
    let result = new PermissionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    return data;
  }

  clone(): PermissionDto {
    const json = this.toJSON();
    let result = new PermissionDto();
    result.init(json);
    return result;
  }
}

export interface IPermissionDto {
  id: number;
  name: string | undefined;
  displayName: string | undefined;
  description: string | undefined;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
  items: PermissionDto[] | undefined;

  constructor(data?: IPermissionDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(PermissionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PermissionDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new PermissionDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): PermissionDtoListResultDto {
    const json = this.toJSON();
    let result = new PermissionDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IPermissionDtoListResultDto {
  items: PermissionDto[] | undefined;
}

export class RegisterInput implements IRegisterInput {
  name: string;
  surname: string;
  userName: string;
  emailAddress: string;
  password: string;
  captchaResponse: string | undefined;

  constructor(data?: IRegisterInput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.userName = _data["userName"];
      this.emailAddress = _data["emailAddress"];
      this.password = _data["password"];
      this.captchaResponse = _data["captchaResponse"];
    }
  }

  static fromJS(data: any): RegisterInput {
    data = typeof data === "object" ? data : {};
    let result = new RegisterInput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["userName"] = this.userName;
    data["emailAddress"] = this.emailAddress;
    data["password"] = this.password;
    data["captchaResponse"] = this.captchaResponse;
    return data;
  }

  clone(): RegisterInput {
    const json = this.toJSON();
    let result = new RegisterInput();
    result.init(json);
    return result;
  }
}

export interface IRegisterInput {
  name: string;
  surname: string;
  userName: string;
  emailAddress: string;
  password: string;
  captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
  canLogin: boolean;

  constructor(data?: IRegisterOutput) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.canLogin = _data["canLogin"];
    }
  }

  static fromJS(data: any): RegisterOutput {
    data = typeof data === "object" ? data : {};
    let result = new RegisterOutput();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["canLogin"] = this.canLogin;
    return data;
  }

  clone(): RegisterOutput {
    const json = this.toJSON();
    let result = new RegisterOutput();
    result.init(json);
    return result;
  }
}

export interface IRegisterOutput {
  canLogin: boolean;
}

export class ResetPasswordDto implements IResetPasswordDto {
  adminPassword: string;
  userId: number;
  newPassword: string;

  constructor(data?: IResetPasswordDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.adminPassword = _data["adminPassword"];
      this.userId = _data["userId"];
      this.newPassword = _data["newPassword"];
    }
  }

  static fromJS(data: any): ResetPasswordDto {
    data = typeof data === "object" ? data : {};
    let result = new ResetPasswordDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["adminPassword"] = this.adminPassword;
    data["userId"] = this.userId;
    data["newPassword"] = this.newPassword;
    return data;
  }

  clone(): ResetPasswordDto {
    const json = this.toJSON();
    let result = new ResetPasswordDto();
    result.init(json);
    return result;
  }
}

export interface IResetPasswordDto {
  adminPassword: string;
  userId: number;
  newPassword: string;
}

export class RoleDto implements IRoleDto {
  id: number;
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;

  constructor(data?: IRoleDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.normalizedName = _data["normalizedName"];
      this.description = _data["description"];
      if (Array.isArray(_data["grantedPermissions"])) {
        this.grantedPermissions = [] as any;
        for (let item of _data["grantedPermissions"])
          this.grantedPermissions.push(item);
      }
    }
  }

  static fromJS(data: any): RoleDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["normalizedName"] = this.normalizedName;
    data["description"] = this.description;
    if (Array.isArray(this.grantedPermissions)) {
      data["grantedPermissions"] = [];
      for (let item of this.grantedPermissions)
        data["grantedPermissions"].push(item);
    }
    return data;
  }

  clone(): RoleDto {
    const json = this.toJSON();
    let result = new RoleDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDto {
  id: number;
  name: string;
  displayName: string;
  normalizedName: string | undefined;
  description: string | undefined;
  grantedPermissions: string[] | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
  items: RoleDto[] | undefined;

  constructor(data?: IRoleDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(RoleDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoleDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): RoleDtoListResultDto {
    const json = this.toJSON();
    let result = new RoleDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDtoListResultDto {
  items: RoleDto[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
  items: RoleDto[] | undefined;
  totalCount: number;

  constructor(data?: IRoleDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(RoleDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): RoleDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): RoleDtoPagedResultDto {
    const json = this.toJSON();
    let result = new RoleDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoleDtoPagedResultDto {
  items: RoleDto[] | undefined;
  totalCount: number;
}

export class RoleEditDto implements IRoleEditDto {
  id: number;
  name: string;
  displayName: string;
  description: string | undefined;
  isStatic: boolean;

  constructor(data?: IRoleEditDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.description = _data["description"];
      this.isStatic = _data["isStatic"];
    }
  }

  static fromJS(data: any): RoleEditDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleEditDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["description"] = this.description;
    data["isStatic"] = this.isStatic;
    return data;
  }

  clone(): RoleEditDto {
    const json = this.toJSON();
    let result = new RoleEditDto();
    result.init(json);
    return result;
  }
}

export interface IRoleEditDto {
  id: number;
  name: string;
  displayName: string;
  description: string | undefined;
  isStatic: boolean;
}

export class RoleListDto implements IRoleListDto {
  id: number;
  name: string | undefined;
  displayName: string | undefined;
  isStatic: boolean;
  isDefault: boolean;
  creationTime: moment.Moment;

  constructor(data?: IRoleListDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.displayName = _data["displayName"];
      this.isStatic = _data["isStatic"];
      this.isDefault = _data["isDefault"];
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): RoleListDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleListDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["displayName"] = this.displayName;
    data["isStatic"] = this.isStatic;
    data["isDefault"] = this.isDefault;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    return data;
  }

  clone(): RoleListDto {
    const json = this.toJSON();
    let result = new RoleListDto();
    result.init(json);
    return result;
  }
}

export interface IRoleListDto {
  id: number;
  name: string | undefined;
  displayName: string | undefined;
  isStatic: boolean;
  isDefault: boolean;
  creationTime: moment.Moment;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
  items: RoleListDto[] | undefined;

  constructor(data?: IRoleListDtoListResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(RoleListDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoleListDtoListResultDto {
    data = typeof data === "object" ? data : {};
    let result = new RoleListDtoListResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    return data;
  }

  clone(): RoleListDtoListResultDto {
    const json = this.toJSON();
    let result = new RoleListDtoListResultDto();
    result.init(json);
    return result;
  }
}

export interface IRoleListDtoListResultDto {
  items: RoleListDto[] | undefined;
}

export enum TenantAvailabilityState {
  _1 = 1,
  _2 = 2,
  _3 = 3,
}

export class TenantDto implements ITenantDto {
  id: number;
  tenancyName: string;
  name: string;
  isActive: boolean;

  constructor(data?: ITenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.tenancyName = _data["tenancyName"];
      this.name = _data["name"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): TenantDto {
    data = typeof data === "object" ? data : {};
    let result = new TenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["tenancyName"] = this.tenancyName;
    data["name"] = this.name;
    data["isActive"] = this.isActive;
    return data;
  }

  clone(): TenantDto {
    const json = this.toJSON();
    let result = new TenantDto();
    result.init(json);
    return result;
  }
}

export interface ITenantDto {
  id: number;
  tenancyName: string;
  name: string;
  isActive: boolean;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
  items: TenantDto[] | undefined;
  totalCount: number;

  constructor(data?: ITenantDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items.push(TenantDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): TenantDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new TenantDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): TenantDtoPagedResultDto {
    const json = this.toJSON();
    let result = new TenantDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface ITenantDtoPagedResultDto {
  items: TenantDto[] | undefined;
  totalCount: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
  id: number;
  tenancyName: string | undefined;
  name: string | undefined;

  constructor(data?: ITenantLoginInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.tenancyName = _data["tenancyName"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): TenantLoginInfoDto {
    data = typeof data === "object" ? data : {};
    let result = new TenantLoginInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["tenancyName"] = this.tenancyName;
    data["name"] = this.name;
    return data;
  }

  clone(): TenantLoginInfoDto {
    const json = this.toJSON();
    let result = new TenantLoginInfoDto();
    result.init(json);
    return result;
  }
}

export interface ITenantLoginInfoDto {
  id: number;
  tenancyName: string | undefined;
  name: string | undefined;
}

export class UserDto implements IUserDto {
  id: number;
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  fullName: string | undefined;
  lastLoginTime: moment.Moment | undefined;
  creationTime: moment.Moment;
  roleNames: string[] | undefined;

  constructor(data?: IUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.userName = _data["userName"];
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.emailAddress = _data["emailAddress"];
      this.isActive = _data["isActive"];
      this.fullName = _data["fullName"];
      this.lastLoginTime = _data["lastLoginTime"]
        ? moment(_data["lastLoginTime"].toString())
        : <any>undefined;
      this.creationTime = _data["creationTime"]
        ? moment(_data["creationTime"].toString())
        : <any>undefined;
      if (Array.isArray(_data["roleNames"])) {
        this.roleNames = [] as any;
        for (let item of _data["roleNames"]) this.roleNames.push(item);
      }
    }
  }

  static fromJS(data: any): UserDto {
    data = typeof data === "object" ? data : {};
    let result = new UserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["userName"] = this.userName;
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["emailAddress"] = this.emailAddress;
    data["isActive"] = this.isActive;
    data["fullName"] = this.fullName;
    data["lastLoginTime"] = this.lastLoginTime
      ? this.lastLoginTime.toISOString()
      : <any>undefined;
    data["creationTime"] = this.creationTime
      ? this.creationTime.toISOString()
      : <any>undefined;
    if (Array.isArray(this.roleNames)) {
      data["roleNames"] = [];
      for (let item of this.roleNames) data["roleNames"].push(item);
    }
    return data;
  }

  clone(): UserDto {
    const json = this.toJSON();
    let result = new UserDto();
    result.init(json);
    return result;
  }
}

export interface IUserDto {
  id: number;
  userName: string;
  name: string;
  surname: string;
  emailAddress: string;
  isActive: boolean;
  fullName: string | undefined;
  lastLoginTime: moment.Moment | undefined;
  creationTime: moment.Moment;
  roleNames: string[] | undefined;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
  items: UserDto[] | undefined;
  totalCount: number;

  constructor(data?: IUserDtoPagedResultDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"]) this.items.push(UserDto.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): UserDtoPagedResultDto {
    data = typeof data === "object" ? data : {};
    let result = new UserDtoPagedResultDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items) data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }

  clone(): UserDtoPagedResultDto {
    const json = this.toJSON();
    let result = new UserDtoPagedResultDto();
    result.init(json);
    return result;
  }
}

export interface IUserDtoPagedResultDto {
  items: UserDto[] | undefined;
  totalCount: number;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
  id: number;
  name: string | undefined;
  surname: string | undefined;
  userName: string | undefined;
  emailAddress: string | undefined;

  constructor(data?: IUserLoginInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.surname = _data["surname"];
      this.userName = _data["userName"];
      this.emailAddress = _data["emailAddress"];
    }
  }

  static fromJS(data: any): UserLoginInfoDto {
    data = typeof data === "object" ? data : {};
    let result = new UserLoginInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["surname"] = this.surname;
    data["userName"] = this.userName;
    data["emailAddress"] = this.emailAddress;
    return data;
  }

  clone(): UserLoginInfoDto {
    const json = this.toJSON();
    let result = new UserLoginInfoDto();
    result.init(json);
    return result;
  }
}

export interface IUserLoginInfoDto {
  id: number;
  name: string | undefined;
  surname: string | undefined;
  userName: string | undefined;
  emailAddress: string | undefined;
}
//#endregion

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else
    return _observableThrow(
      new ApiException(message, status, response, headers, null)
    );
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
